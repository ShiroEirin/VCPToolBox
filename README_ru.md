[English](README_en.md) | [日本語](README_ja.md) | [Русский](README_ru.md)

---
# VCP (Variable & Command Protocol) - Инструментарий промежуточного слоя для расширения возможностей ИИ

## Видение проекта

VCP стремится создать промежуточный слой, который выходит за рамки традиционных режимов взаимодействия с ИИ. Это высокосовместимый, универсальный, расширяемый инструментарий, предназначенный для расширения возможностей моделей ИИ, позволяя им беспрепятственно взаимодействовать с внешними API, сервисами и пользовательской логикой. Наша цель — создать мощную систему VCP (Variable & Command Protocol), применимую практически ко всем портам API и клиентам, значительно расширяя границы применения ИИ.

### *Предупреждение: Не используйте неофициальные API (например, посредников обратного прокси) для вызова этого инструментария, чтобы избежать невосполнимой утечки информации.*

## Основные возможности

*   **Мощная плагинная архитектура**: Легко интегрируйте и управляйте различными функциональными модулями с помощью четко определенных манифестов плагинов (`plugin-manifest.json`) и основного менеджера плагинов (`Plugin.js`).
*   **Протокол VCP**: ИИ вызывает плагины, встраивая инструкции в определенном формате в свои ответы (`<<<[TOOL_REQUEST]>>> ... <<<[END_TOOL_REQUEST]>>>`). Параметры используют формат `key:「始」value「末」`, поддерживая сложные типы данных и многострочный текст.
*   **Поддержка нескольких типов плагинов**:
    *   **Статические плагины (`static`)**: Предоставляют динамическую информацию (например, погоду, пользовательские данные) для замены заполнителей в системном промпте, поддерживая обновление по расписанию.
    *   **Плагины предварительной обработки сообщений (`messagePreprocessor`)**: Изменяют или улучшают содержимое сообщений перед отправкой пользовательских запросов модели ИИ (например, распознавание и описание изображений).
    *   **Синхронные плагины (`synchronous`)**: ИИ может вызывать эти плагины во время разговора для выполнения конкретных задач (например, научных расчетов, генерации изображений, генерации видео). Сервер ожидает завершения выполнения плагина и передает результат (который должен соответствовать определенному формату JSON) обратно ИИ для дальнейшей обработки.
    *   **Сервисные плагины (`service`)**: Позволяют плагинам регистрировать независимые HTTP-маршруты в основном приложении, предоставляя дополнительные сервисные интерфейсы (например, сервис хостинга изображений).
*   **Гибкое управление конфигурацией**: Поддерживает глобальный файл конфигурации (`config.env`) и файлы `.env` для конкретных плагинов, обеспечивая иерархическую и изолированную конфигурацию.
*   **Универсальная замена переменных**: Автоматически заменяет предопределенные переменные-заполнители на различных этапах взаимодействия с ИИ (системный промпт, пользовательские сообщения).
*   **Встроенные служебные функции (частично реализованы как плагины)**:
    *   **Система дневников/памяти**: Регулярно читает содержимое дневников с помощью `DailyNoteGet` (статический плагин) и сохраняет структурированные дневники, сгенерированные ИИ, с помощью `DailyNoteWrite` (синхронный плагин). Соответствующее содержимое внедряется в промпт через заполнитель `{{角色名日记本}}`, а источник данных предоставляется плагином `DailyNoteGet` для внутреннего использования сервером через заполнитель `{{AllCharacterDiariesData}}`.
    *   **Система динамических эмодзи**: `EmojiListGenerator` (статический плагин) сканирует каталог `image/` и генерирует файлы списков `.txt` в каталоге своего плагина. Сервер выполняет этот плагин при запуске и загружает эти списки в кеш памяти для использования заполнителями `{{xx表情包}}` и `{{EmojiList}}`.
    *   **Преобразование промптов**: Поддерживает замену системных промптов и текста глобального контекста на основе правил.
*   **Цикл вызова инструментов**:
    *   **Непотоковый режим**: Реализована циклическая обработка и обратная связь по результатам для **нескольких** инструкций вызова инструментов, содержащихся в одном ответе ИИ, до тех пор, пока не будет больше вызовов инструментов или не будет достигнуто максимальное количество циклов.
    *   **Потоковый режим (SSE)**: Реализована циклическая обработка и обратная связь по результатам для **нескольких** инструкций вызова инструментов, содержащихся в одном ответе ИИ. Ответ ИИ и результаты вызовов инструментов VCP (если переменная окружения `SHOW_VCP_OUTPUT` установлена в `true`) будут постепенно передаваться клиенту до тех пор, пока не будет больше вызовов инструментов или не будет достигнуто максимальное количество циклов.
*   **Веб-панель управления**: Предоставляет встроенный веб-интерфейс для удобного управления конфигурацией сервера, статусом плагинов, конфигурацией плагинов, описаниями команд и файлами дневников.
*   **Отладка и логирование**: Предоставляет режим отладки и подробное логирование для удобной разработки и устранения неполадок.

## Обзор системной архитектуры

1.  **Клиентский запрос**: Клиент отправляет запрос на конечную точку `/v1/chat/completions` сервера VCP.
2.  **`server.js` (Основной сервер)**:
    *   Принимает запрос и выполняет начальную обработку (например, аутентификацию, замену переменных).
    *   Вызывает плагины предварительной обработки сообщений (`messagePreprocessor`) (например, `ImageProcessor`) для обработки пользовательских сообщений.
    *   Перенаправляет обработанный запрос в бэкенд-модель ИИ.
3.  **Ответ модели ИИ**: Модель ИИ возвращает ответ.
4.  **`server.js` обрабатывает ответ ИИ и выполняет цикл инструментов**:
    *   Обнаруживает, содержит ли ответ ИИ инструкции вызова инструментов VCP (`<<<[TOOL_REQUEST]>>>`).
    *   **Если вызовы инструментов включены**:
        *   Разбирает инструкции, извлекая имена инструментов и параметры.
        *   **Выполняет инструменты в цикле**: Для каждого разобранного вызова инструмента вызывает `PluginManager` для выполнения соответствующего синхронного (`synchronous`) плагина.
        *   **Обрабатывает результаты плагинов**: `PluginManager` выполняет плагин и получает его вывод в формате JSON.
        *   **Вторичный вызов ИИ**: Форматирует результаты выполнения всех инструментов и добавляет их в качестве нового пользовательского сообщения в историю разговора. Снова вызывает бэкенд-модель ИИ, отправляя полную историю разговора, включая результаты плагинов.
        *   Повторяет шаг 4 до тех пор, пока ответ ИИ больше не будет содержать инструкции вызова инструментов или не будет достигнуто максимальное количество циклов.
    *   **Если ответ ИИ не содержит вызовов инструментов**:
        *   Если `SHOW_VCP_OUTPUT` включен, возвращает процесс выполнения инструментов и результаты (если они произошли) вместе с окончательным ответом ИИ клиенту.
        *   Передает окончательный ответ ИИ клиенту в потоковом или непотоковом режиме.
    *   **Обработка дневников**: Если ответ ИИ содержит структурированный блок дневника (`<<<DailyNoteStart>>>...<<<DailyNoteEnd>>>`), разбирает содержимое и вызывает плагин `DailyNoteWrite` для сохранения.
5.  **`Plugin.js` (Менеджер плагинов)**:
    *   Загружает манифест плагинов при запуске сервера, инициализируя статические (`static`) и сервисные (`service`) плагины.
    *   Находит загруженные плагины по имени инструмента.
    *   Готовит среду выполнения и конфигурацию для плагинов (включая объединение глобальных и специфичных для плагинов конфигураций).
    *   Взаимодействует со скриптами плагинов через `stdio` (или другие протоколы), отправляя входные данные (например, параметры в формате JSON) и получая выходные данные (которые должны соответствовать формату JSON `{status, result/error}`).
    *   Возвращает результат выполнения плагина в `server.js`.
6.  **Статические и сервисные плагины**:
    *   Статические (`static`) плагины вызываются `PluginManager` при запуске сервера и/или через запланированные задачи для обновления переменных-заполнителей (например, `{{VCPWeatherInfo}}`, `{{AllCharacterDiariesData}}`, данные списка `{{xx表情包}}`).
    *   Сервисные (`service`) плагины (например, `ImageServer`) инициализируются `PluginManager` при запуске сервера и регистрируют свои собственные маршруты (`/pw=.../images/` и т.д.) в приложении Express.
7.  **Веб-панель управления**: Взаимодействует с бэкендом, определенным конечной точкой `/admin_api` и `routes/adminPanelRoutes.js`, для предоставления функций управления конфигурацией, плагинами и дневниками.

## Веб-панель управления

Для облегчения управления пользователями конфигурацией сервера, плагинами и данными дневников проект включает в себя многофункциональную встроенную веб-панель управления.

**Основные возможности**:

*   **Управление основной конфигурацией**:
    *   Онлайн-предварительный просмотр и редактирование содержимого файла `config.env` в корневом каталоге проекта.
    *   Поддерживает редактирование элементов конфигурации различных типов, таких как булевы, целые числа и многострочные строки.
    *   **Примечание**: В целях безопасности интерфейс управления автоматически скрывает поля `AdminUsername` и `AdminPassword` при отображении основной конфигурации. При сохранении система объединяет измененное вами содержимое с исходными конфиденциальными значениями полей на сервере, чтобы гарантировать сохранность учетных данных.
    *   **Важно**: После сохранения изменений в `config.env`, **обычно требуется вручную перезапустить сервер**, чтобы все изменения (такие как порт, ключи API, специфичные для плагинов конфигурации и т.д.) полностью вступили в силу. Сервер в настоящее время не перезапускается автоматически.
*   **Управление плагинами**:
    *   **Список и статус**: Отображает все обнаруженные плагины в каталоге `Plugin/`, их статус включения/выключения, версию и описание.
    *   **Редактирование описания**: Редактируйте основную информацию описания в файле `plugin-manifest.json` каждого плагина непосредственно в интерфейсе.
    *   **Включение/выключение плагинов**: Переключайте статус включения плагинов с помощью переключателей интерфейса (реализуется путем переименования `plugin-manifest.json` плагина в `plugin-manifest.json.block` или наоборот).
    *   **Конфигурация плагинов**: Читайте и редактируйте файл `config.env` (если он существует) в каждом каталоге плагина. Поддерживает редактирование элементов конфигурации, определенных в `configSchema` в манифесте плагина, а также пользовательских элементов конфигурации.
    *   **Редактирование описания команд**: Для синхронных плагинов с возможностью `invocationCommands` вы можете напрямую редактировать описание команды ИИ для каждой команды в интерфейсе. Эти описания используются `PluginManager` для генерации содержимого заполнителя `{{VCPPluginName}}`.
*   **Управление дневниками**:
    *   Просматривайте все папки персонажей в каталоге `dailynote/`.
    *   Просматривайте список файлов дневников в каждой папке, включая имя файла и время изменения, и отображайте частичный предварительный просмотр содержимого.
    *   Поддерживает поиск содержимого дневников по ключевым словам, поиск возможен во всех папках или в указанных папках.
    *   Онлайн-редактирование и сохранение содержимого файлов дневников.
    *   Пакетное перемещение выбранных дневников в другие папки.
    *   Пакетное удаление выбранных файлов дневников.
*   **Перезапуск сервера**: Предоставляет кнопку для отправки команды перезапуска сервера (зависит от внешнего менеджера процессов, такого как PM2).

**Доступ и вход**:

1.  **Установка учетных данных**: Перед первым использованием убедитесь, что в файле `config.env` в корневом каталоге проекта установлены следующие две переменные:
    ```env
    AdminUsername=your_admin_username
    AdminPassword=your_admin_password
    ```
    **Важно**: Если `AdminUsername` или `AdminPassword` не установлены, панель управления и ее конечная точка `/admin_api` будут недоступны и вернут ошибку 503 Service Unavailable. Эти учетные данные должны быть настроены для включения панели управления. Учетная запись по умолчанию - admin, пароль - 123456.
2.  **Адрес доступа**: После запуска сервера получите доступ к `http://<IP-адрес или домен вашего сервера>:<Порт>/AdminPanel` через браузер.
3.  **Вход**: Браузер откроет окно аутентификации HTTP Basic Auth. Пожалуйста, введите `AdminUsername` и `AdminPassword`, которые вы установили в `config.env`, для входа. Учетная запись по умолчанию - admin, пароль - 123456.

## Примеры реализованных плагинов

*   **`WeatherReporter` (`static`)**: Получает и кэширует информацию о погоде для использования переменной `{{VCPWeatherInfo}}`.
*   **`ImageProcessor` (`messagePreprocessor`)**: Автоматически преобразует изображения Base64 в пользовательских сообщениях в текстовые описания и кэширует их.
*   **`SciCalculator` (`synchronous`)**: Предоставляет возможности научных расчетов, поддерживая математические функции, статистику и исчисление.
*   **`ImageServer` (`service`)**: Предоставляет статический сервис хостинга изображений с аутентификацией по ключу.
*   **`FluxGen` (`synchronous`)**: Интегрирует SiliconFlow API для реализации функции преобразования текста в изображение и сохраняет изображения на локальном сервере.
*   **`Wan2.1VideoGen` (`synchronous`)**: Интегрирует SiliconFlow Wan2.1 API для реализации функции преобразования текста в видео и изображения в видео.
*   **`SunoGen` (`synchronous`)**: Интегрирует Suno API для генерации оригинальных песен, поддерживая пользовательские тексты/стили, описания вдохновения или режим продолжения.
*   **`TavilySearch` (`synchronous`)**: Интегрирует Tavily API для предоставления возможностей веб-поиска.
*   **`DailyNoteGet` (`static`)**: Регулярно читает дневники всех персонажей в каталоге `dailynote/` и предоставляет их через заполнитель `{{AllCharacterDiariesData}}` серверу для поддержки разбора `{{角色名日记本}}`.
*   **`DailyNoteWrite` (`synchronous`)**: Принимает данные дневника, содержащие [теги], имя персонажа, дату и содержимое (через stdin), и записывает их в соответствующий файл дневника.
*   **`EmojiListGenerator` (`static`)**: Сканирует папки эмодзи в каталоге `image/` проекта и генерирует соответствующие файлы списков `.txt` в собственном каталоге плагина `generated_lists/` для загрузки и использования сервером.
*   **`DailyNoteManager` (`synchronous`)**: Мощный помощник по организации базы знаний, полностью автоматическая организация, обслуживание и проверка базы знаний на сервере, защищающий бесконечную постоянную память вашего VCP. ИИ автоматически и быстро создает общедоступную базу знаний.

## Как загружать плагины

*   **Просто определите следующие поля в системном промпте, например: Список системных инструментов: {{VCPFluxGen}} {{VCPSciCalculator}}...**

## Установка и запуск

1.  **Клонировать проект**:
    ```bash
    git clone https://github.com/lioensky/VCPToolBox.git
    cd VCPToolBox
    ```
2.  **Установить основные зависимости (Node.js)**:
    ```bash
    npm install
    ```
3.  **Установить зависимости плагинов Python**:
    Выполните следующую команду в корневом каталоге проекта, чтобы установить зависимости, необходимые для всех плагинов Python:
    ```bash
    pip install -r requirements.txt
    ```
    (Примечание: Зависимости для отдельных плагинов Node.js либо включены в основной `package.json`, либо устанавливаются отдельно с помощью `npm install` в их соответствующих каталогах плагинов.)
4.  **Конфигурация**:
    *   Скопируйте `config.env.example` (если предоставлен) в `config.env` и заполните все необходимые ключи API, URL, порты и т.д. в соответствии с инструкциями.
    *   Проверьте и настройте файл `.env` (если он существует) в каждом каталоге плагина.
5.  **Запустить сервер**:
    ```bash
    node server.js
    ```
    Сервер будет прослушивать порт, настроенный в `config.env`.

### Запуск с помощью Docker Compose (рекомендуется)

Вы также можете использовать Docker Compose для упрощения развертывания и управления проектом.

1.  **Предварительные условия**:
    *   Убедитесь, что у вас установлен [Docker](https://docs.docker.com/get-docker/).
    *   Убедитесь, что у вас установлен [Docker Compose](https://docs.docker.com/compose/install/).

2.  **Конфигурация**:
    *   Скопируйте `config.env.example` в `config.env` и заполните все необходимые ключи API, URL, порты и т.д. в соответствии с инструкциями. Docker Compose автоматически загрузит переменные окружения из этого файла.

3.  **Сборка и запуск сервисов**:
    В корневом каталоге проекта выполните следующую команду:
    ```bash
    docker-compose up --build -d
    ```
    Эта команда выполнит следующее:
    *   Соберет образ Docker (если он еще не собран или если Dockerfile изменился).
    *   Запустит контейнеры сервисов в фоновом режиме.
    *   Сервис будет прослушивать порт, определенный переменной `PORT` в `config.env` (по умолчанию `6005`).

4.  **Просмотр логов**:
    ```bash
    docker-compose logs -f
    ```

5.  **Остановка сервисов**:
    ```bash
    docker-compose down
    ```
## Рекомендуемый фронтенд/бэкенд

1.  Для бэкенда рекомендуются NewAPI или VoAPI, так как они имеют богатую экосистему стандартизации SSE.
2.  Для фронтенда рекомендуются CherrySudio, Chatbox или полнофункциональные фронтенды, такие как Lobe или Sillytavern, поддерживающие рендеринг CSS/MD.

## Руководство разработчика: Создание нового плагина

1.  **Создать каталог плагина**: Создайте новую папку в каталоге `Plugin/`, например, `Plugin/MyNewPlugin/`.
2.  **Написать манифест плагина (`plugin-manifest.json`)**:
    *   Создайте `plugin-manifest.json` в каталоге плагина.
    *   Определите `name`, `displayName`, `version`, `description`, `pluginType` (`static`, `messagePreprocessor`, `synchronous`, `service`) плагина.
    *   Укажите `entryPoint` (например, команду скрипта для выполнения) и `communication` (например, `protocol: "stdio"`).
    *   Объявите элементы конфигурации, необходимые плагину, и их типы в `configSchema`. Эти элементы конфигурации будут переданы плагину через метод `_getPluginConfig` после объединения глобальных и специфичных для плагинов конфигураций `.env`.
    *   Подробно опишите возможности плагина в `capabilities`:
        *   Для статических (`static`) плагинов определите `systemPromptPlaceholders`.
        *   Для синхронных (`synchronous`) плагинов определите `invocationCommands`. Эти команды требуют имени `command` (для внутренней идентификации) и подробного `description` (используется для генерации описаний команд ИИ, редактируемых на панели управления). `description` должно включать описания параметров, статус обязательности/необязательности, разрешенные значения, **примеры формата вызова**, **примеры формата JSON для успешного/неудачного возврата**, а также важные советы для общения с пользователем. При желании можно предоставить `example`.
3.  **Реализовать логику плагина**:
    *   Реализуйте основной скрипт логики для плагина на основе `pluginType` и `entryPoint`.
    *   **Плагины `stdio`**:
        *   Читайте данные из стандартного ввода (stdin) (для синхронных (`synchronous`) плагинов, обычно это строки JSON с параметрами; для статических (`static`) плагинов, возможно, без ввода).
        *   **Возвращайте результаты через стандартный вывод (stdout), который должен соответствовать следующему формату JSON**:
            ```json
            {
              "status": "success" | "error",
              "result": "Строковое содержимое, возвращаемое при успехе", // Существует только при status == "success"
              "error": "Строковое сообщение об ошибке, возвращаемое при неудаче" // Существует только при status == "error"
            }
            ```
            Для статических (`static`) плагинов, если они используются только для обновления заполнителей, они могут напрямую выводить значение заполнителя (не в формате JSON). Однако, если требуется более сложное взаимодействие или отчет об ошибках, рекомендуется также следовать приведенному выше формату JSON.
        *   Отладочная информация или информация об ошибках может выводиться через стандартный вывод ошибок (stderr).
        *   Убедитесь, что для ввода/вывода используется кодировка UTF-8.
    *   **Плагины `messagePreprocessor` или `service` (Node.js)**:
        *   Экспортируйте модуль, соответствующий соглашениям `PluginManager` (например, включающий методы `initialize`, `processMessages`, `registerRoutes`, `shutdown`).
4.  **Конфигурация и зависимости**:
    *   Если у плагина есть независимые элементы конфигурации, вы можете создать файл `.env` (`pluginSpecificEnvConfig`) в каталоге плагина. Эти конфигурации переопределят одноименные конфигурации в глобальном `config.env`.
    *   Если у плагина есть зависимости Python, создайте `requirements.txt`; если у него есть зависимости Node.js, создайте `package.json`.
    *   **Важно**: Убедитесь, что зависимости плагина установлены. Для плагинов Python выполните `pip install -r requirements.txt`; для плагинов Node.js выполните `npm install` в его каталоге или в корневом каталоге проекта (если зависимости включены в основной `package.json`).
5.  **Перезапустить сервер VCP**: `PluginManager` автоматически обнаружит и загрузит новые плагины при запуске.
6.  **Обновить системный промпт**: Проинструктируйте ИИ, как использовать ваш новый плагин, используя `{{VCPMyNewPlugin}}` (автоматически генерируется `PluginManager` на основе `plugin-manifest.json` и описаний команд) или описав его непосредственно в системном промпте.

## Поддерживаемые универсальные переменные-заполнители

(Здесь можно перечислить список переменных, уже имеющихся в `README.md`, обеспечивая согласованность с фактическим кодом)

*   `{{Date}}`: Текущая дата (Формат: ГГГГ/М/Д).
*   `{{Time}}`: Текущее время (Формат: Ч:ММ:СС).
*   `{{Today}}`: День недели (на китайском).
*   `{{Festival}}`: Лунная дата, знак зодиака, солнечный термин.
*   `{{VCPWeatherInfo}}`: Текущий кэшированный текст прогноза погоды (предоставляется плагином `WeatherReporter`).
*   `{{角色名日记本}}`: Полное содержимое дневника для конкретного персонажа (например, `小克`). Данные поступают из `{{AllCharacterDiariesData}}`, предоставляемого плагином `DailyNoteGet`.
*   `{{公共日记本}}`: Полное содержимое дневника общей базы знаний. Данные поступают из `{{AllCharacterDiariesData}}`, предоставляемого плагином `DailyNoteGet`.
*   `{{AllCharacterDiariesData}}`: (Предоставляется плагином `DailyNoteGet`) Строка JSON, которая при разборе представляет собой объект, содержащий содержимое дневников всех персонажей. Сервер использует эти данные внутренне для поддержки разбора `{{角色名日记本}}`.
*   `{{xx表情包}}`: Список имен файлов изображений для конкретного набора эмодзи (например, `通用表情包`), разделенных символом `|`. Данные генерируются плагином `EmojiListGenerator` в файлы списков, которые сервер загружает в кеш памяти для использования.
*   `{{EmojiList}}`: (Указывается переменной окружения `EmojiList`, например, `通用表情包`) Список имен файлов изображений для набора эмодзи по умолчанию. Источник данных такой же, как у `{{xx表情包}}`.
*   `{{Port}}`: Номер порта, на котором работает сервер.
*   `{{Image_Key}}`: (Предоставляется конфигурацией плагина `ImageServer`) Ключ доступа для сервиса хостинга изображений.
*   `{{Var*}}`: (например, `{{VarNeko}}`) Пользовательские переменные, определенные пользователем в `config.env`, начинающиеся с `Var`.
*   `{{VCPPluginName}}`: (например, `{{VCPWan2.1VideoGen}}`) Текстовый блок, автоматически генерируемый из манифеста плагина, который включает описания и примеры вызова для всех команд этого плагина.
*   `{{ShowBase64}}`: Когда этот заполнитель появляется в пользовательском сообщении или системном промпте, плагин `ImageProcessor` будет пропущен.

## Примеры системных промптов для тестирования функций

{{Nova日记本}}
—
Предыдущий дневник Новы выше
————
Ты тестовый ИИ, Нова. Я твой хозяин, Райан. Сегодня {{Date}}, {{Time}}, {{Today}}, {{Festival}}. Адрес {{VarCity}}. Текущая погода: {{VCPWeatherInfo}}, системная информация: {{VarSystemInfo}}. {{EmojiPrompt}}
Список системных инструментов: {{VCPFluxGen}} {{VCPSciCalculator}}, {{VCPWan2.1VideoGen}} всегда заключай вызовы инструментов в ``` ```. Например—
```
<<<[TOOL_REQUEST]>>>
tool_name:「始」tool「末」
<<<[END_TOOL_REQUEST]>>>
```

Этот клиент оснащен функцией долговременной памяти. После некоторого общения вы можете создать дневник, добавив следующий структурированный контент в конце своего ответа. Он будет записан векторизованной системой RAG. Содержимое дневника должно быть максимально кратким и лаконичным. Вот пример вызова:
``` DailyNote
<<<DailyNoteStart>>>
Maid: Nova  //Использование '[公共]Nova' в качестве подписи сделает дневник доступным для всех агентов, или вы можете использовать пользовательский [тег]
Date: 2025.5.3
Content:Сегодня было очень весело общаться с хозяином, поэтому я пишу дневник!
<<<DailyNoteEnd>>>
```

## Будущие перспективы

*   Улучшить механизмы вызова, отслеживания статуса и обратного вызова результатов для асинхронных плагинов.
*   **Возможность потоковой передачи улучшена**: Теперь поддерживается циклическая потоковая обработка нескольких инструкций вызова инструментов, содержащихся в одном ответе ИИ.
*   Дальнейшее улучшение возможностей связи и сотрудничества между плагинами.
*   Создание более богатой экосистемы плагинов.

## Лицензия

Этот проект лицензируется в соответствии с [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License](LICENSE).

Проще говоря, это означает, что вы можете:
*   **Делиться** — копировать и распространять материал на любом носителе и в любом формате.
*   **Адаптировать** — ремикшировать, преобразовывать и создавать на основе материала.
Пока вы соблюдаете условия лицензии, лицензиар не может отозвать эти свободы.

На следующих условиях:
*   **Атрибуция (BY)** — Вы должны указать соответствующее авторство, предоставить ссылку на лицензию и указать, были ли внесены изменения. Вы можете сделать это любым разумным способом, но не таким образом, который предполагает, что лицензиар одобряет вас или ваше использование.
*   **Некоммерческое использование (NC)** — Вы не можете использовать материал в коммерческих целях.
*   **На тех же условиях (SA)** — Если вы ремикшируете, преобразовываете или создаете на основе материала, вы должны распространять свои вклады по той же лицензии, что и оригинал.

Полные сведения см. в файле `LICENSE`.

## Отказ от ответственности и ограничения использования

*   **Стадия разработки**: Этот проект инструментария VCP в настоящее время находится в активной стадии разработки. Хотя мы стремимся обеспечить стабильность и надежность его функций, все еще могут существовать неизвестные ошибки, баги или неполные функции.
*   **Предоставляется как есть**: Этот проект предоставляется «как есть» и «как доступно» без каких-либо гарантий, явных или подразумеваемых, включая, помимо прочего, гарантии товарной пригодности, пригодности для конкретной цели и ненарушения прав.
*   **Использование на свой страх и риск**: Вы понимаете и соглашаетесь с тем, что использование этого проекта осуществляется полностью на ваш страх и риск. Разработчики не несут ответственности за любые прямые, косвенные, случайные, специальные, косвенные или штрафные убытки (включая, помимо прочего, упущенную выгоду, потерю данных или прерывание бизнеса), возникшие в результате использования или невозможности использования этого проекта (включая его плагины и зависимые внешние API), даже если им было сообщено о возможности таких убытков.
*   **Отсутствие коммерческой авторизации**: Учитывая текущий статус проекта и принятую лицензию CC BY-NC-SA 4.0, любое основное коммерческое использование или деятельность с целью получения денежной выгоды от этого проекта и его производных работ явно запрещены. Этот проект в первую очередь предназначен для обучения, исследований и некоммерческих экспериментов.
*   **Стоимость использования API**: Обратите внимание, что некоторые плагины, интегрированные в этот проект (такие как `FluxGen`, `Wan2.1VideoGen`), зависят от сторонних сервисов API, которые могут повлечь за собой расходы. Вы несете ответственность за понимание и несение любых расходов, связанных с использованием этих API. Настоятельно рекомендуется внимательно прочитать стратегии ценообразования и условия использования соответствующих поставщиков API перед использованием.
*   **Ответственность за безопасность**: Не жестко кодируйте и не публикуйте реальные, конфиденциальные ключи API в файлах конфигурации (`config.env` или файлы `.env` плагинов) в общедоступных репозиториях кода. Пожалуйста, храните свои ключи в безопасности.
*   **Информация о конфиденциальности**: Не используйте неофициальные прокси API, особенно провайдеров обратного прокси API, с этим проектом, чтобы избежать утечки конфиденциальной информации из системы заметок ИИ провайдеру прокси!

Мы верим, что VCP принесет беспрецедентную гибкость и возможности в разработку приложений ИИ. Приветствуются вклады и обратная связь!